# -*- coding: utf-8 -*-
"""
Created on Thu Jul 30 18:49:55 2020

@author: naomy
"""



import matplotlib.pyplot as plt
import numpy as np
import scipy.integrate as integrate

#AQUI EU VOU CALCULAR A INTEGRAL DA TRANSMISSÃO COMO FUNÇÃO DE R, FAZENDO UM LOOP NOS VALORES DE X
c = 3*10**8 
deltac = 2*np.pi*0.1*10**6
omegap = 0.1*10**6
omegac = 50*10**6
gammap = 2*np.pi*6.06*10**6#valor tirado do data sheet do Rb87
g = 0
N = 5*10**14
kp = 2*np.pi/(780*10**-9)
kc = 2*np.pi/(480*10**-9)
z = 0.08 #7cm
epsilon0 = 8.854*10**(-12)
hbar = 1.054*10**-34
mu12 = 3.584*10**-29
u = 290.5 #root mean square velocity
x = np.arange(-70*10**6, 70*10**6, 1*10**5) #\Delta_{p}
w0p = 140*10**-6 #integral é feita na região da cintura do feixe de prova
w0c = 180*10**-6

teste1 = omegap/gammap#<<1 na EIT
teste2 = omegac/gammap


#Nom = gammap*g**2 - g*x*(x + deltac) + g*omegac**2 + (x + deltac)*(x*g + gammap*(x + deltac))
Nom = 4*gammap*(x + deltac)**2
#Den = 2*((gammap*g - x*(x + deltac) + omegac**2)**2 + (x*g + gammap*(x + deltac))**2)
Den = (4*gammap**2)*((x+deltac)**2) + (omegac**2 - 4*x*(x + deltac))**2
A = (2*N*kp*Nom*(mu12**2))/(epsilon0*hbar*Den)#absorção para o feixe gaussiano
T = np.exp(-A*z) #transmissão do feixe gaussiano



#--------------PARTE QUE CALCULA O EIT PARA O FEIXE LG, INTEGRANDO A TRANSMISSÃO EM R-----------------


result_array = np.empty((0))
for i in range (-70*10**6, 70*10**6, 1*10**5): #LOOP PARA INTEGRAR EM TODOS OS VALORES DE X
#Nom = gammap*g**2 - g*x*(x + deltac) + g*(omegac*np.sqrt(2)*(t/w0)**2) + (x + deltac)*(x*g + gammap*(x + deltac))
#Nom = gamma13*(4*x**2+x*deltac-2*gammap*gamma13-omegac**2) + 4*(x+deltac)*(x*gamma13+2*x*gammap-2*deltac*gammap)
#Den = 2*((gammap*g - x*(x + deltac) + (omegac*np.sqrt(2)*(t/w0)*np.exp((-t/w0)**2))**2)**2 + (x*g + gammap*(x + deltac))**2)
    B = (2*N*kp*z*mu12**2)/(epsilon0*hbar) #constantes que entram no cálculo da absorção
#transmissão = exp(-a*z)
    T_LG = integrate.quad(lambda t: np.exp(-B*((4*gammap*(i+deltac)**2)/(4*(gammap**2)*(i+deltac)**2 + ((omegac*np.sqrt(2)*(t/w0c)*np.exp(-(t/w0c)**2))**2 - 4*i*(i+deltac))**2)))*t, 0, w0p)
    #t é o r, sei lá por que usei t 
    result = 2*T_LG[0]/w0p**2

    #print(result)
    result_array = np.append(result_array, [result], axis=0)
    
  #-----------------------------COM ALARGAMENTO DOPPLER/HOT ATOMS----------------------------------------  
result_arraydp = np.empty((0))#FEIXE GAUSSIANO -----------------------------------
for i in range (-70*10**6, 70*10**6, 1*10**5):
    #feixe Gaussiano com alargamento doppler. A integral é feita somente na distribuição de velocidade dos átomos
    A = integrate.quad(lambda v: ((np.exp(-v**2/u**2)*8*N*kp*gammap*(mu12**2))/(u*np.sqrt(np.pi)*epsilon0*hbar))*((i+deltac+kp*v-kc*v)**2/(4*(gammap**2)*(i+deltac+kp*v-kc*v)**2 + (omegac**2 - 4*(i+kp*v)*(i+deltac+kp*v-kc*v))**2)), -np.inf, np.inf)
    #T_LG = integrate.quad(lambda t: np.exp(-B*(gammap*g**2 - g*i*(i + deltac) + g*(omegac*np.sqrt(2)*(t/w0)*np.exp(-(t/w0)**2))**2 + (i + deltac)*(i*g + gammap*(i + deltac)))/(2*((gammap*g - i*(i + deltac) + (omegac*np.sqrt(2)*(t/w0)*np.exp(-(t/w0)**2))**2)**2 + (i*g + gammap*(i + deltac))**2)))*t, 0, w0)
    resultdp = np.exp(-A[0]*z)
    result_arraydp = np.append(result_arraydp, [resultdp], axis=0)   
    
result_arrayLG = np.empty((0))#FEIXE LG ------------------------------------------
for n in range (-70*10**6, 70*10**6, 1*10**5):
    f = lambda v, r: r*((np.exp(-v**2/u**2)*8*N*kp*gammap*mu12**2)/(u*np.sqrt(np.pi)*epsilon0*hbar))*((n+deltac-kp*v+kc*v)**2/(4*gammap**2*(n+deltac-kp*v+kc*v)**2 + ((omegac*np.sqrt(2)*(r/w0c)*np.exp(-(r/w0c)**2))**2-4*(n-kp*v)*(n+deltac-kp*v+kc*v))**2))
    A_LG = integrate.dblquad(f, 0, w0p, lambda v: -np.inf, lambda v: np.inf)#integro primeiro em v e por último em r
    result2 = np.exp(-A_LG[0]*(2/w0p**2)*z)#fator 2/w0p**2 é normalização da curva
    result_arrayLG = np.append(result_arrayLG, [result2], axis=0)
    

#NESSA PARTE EU VOU PLOTAR O DELTAP E A TRANSMISSÃO CALCULADA PARA CADA VALOR E PARA CADA FEIXE
print(teste1, teste2)
plt.plot(x, result_array, label='LG', color='r')
plt.plot(x, T, label='Gaussiano', color='g')
plt.plot(x, result_arraydp, label='Gaussiano com Doppler', color='b')
plt.plot(x, result_arrayLG, label='LG com Doppler', color='y')
plt.xlabel('$\Delta_{p}$(MHz)')
plt.ylabel('Transmissão')
plt.legend()
plt.savefig('EIT.pdf', format='pdf', dpi=1000)
plt.show()
